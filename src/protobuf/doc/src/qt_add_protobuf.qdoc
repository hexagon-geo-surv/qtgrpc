// Copyright (C) 2022 The Qt Company Ltd.
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GFDL-1.3-no-invariants-only

/*!
\page qt_add_protobuf.html
\ingroup cmake-commands-qtprotobuf

\title qt_add_protobuf
\target qt6_add_protobuf
\summary {Generates Qt-based C++ source code using a protobuf schema}
\preliminarycmakecommand
\cmakecommandsince 6.5

Usually \c qtprotobufgen would be invoked through CMake using the
\c qt_add_protobuf command.

\badcode
    qt_add_protobuf(<target>
        PROTO_FILES <file> ...
        [COPY_COMMENTS]
        [GENERATE_PACKAGE_SUBFOLDERS]
        [EXTRA_NAMESPACE <namespace>]
        [EXPORT_MACRO <infix>]
        [QML [QML_URI <uri>]]
        [PROTO_INCLUDES <path> ...]
        [OUTPUT_DIRECTORY <dir>]
        [OUTPUT_HEADERS <var>]
        [OUTPUT_TARGETS <var>]
    )
\endcode

The source files generated by \c qtprotobufgen are then added to the target.
If the target already exists, the files are \e added to the target source
list. If the target doesn't exist, it is created as a library which you must
link to.

\section1 Arguments
\list
    \include qtprotoccommon-options.qdocinc
    \li \c QML enables QProtobufMessage types in QML context by registering
        them as a QML module. For such purpose, the \l {qt_add_qml_module}
        command is called inside the \c qt_add_protobuf command.
        Every QML module has to define a \c URI name. Other QML modules may
        use this name in \l{qtqml-syntax-imports.html}{import statements}
        to import the module into a user application. Use the \c QML_URI
        option to set the \c URI name. It has to be specified in dotted
        notation, e.g. \c {Qt.Protobuf.Package}.
        If \c QML_URI is omitted, then the protobuf package name will be used
        as the module \c URI.
        Note that when \c QML argument is used, the \c qt_add_protobuf
        command always creates a new QML module; therefore, it cannot be used
        to extend existing targets. For example, following cases are invalid:
        \badcode
            qt_add_qml_module(targetname
                ...
            )

            qt_add_protobuf(targetname
                QML
                ...
            )
        \endcode

        \badcode
            qt_add_executable(targetname
                ...
            )

            qt_add_protobuf(targetname
                QML
                ...
            )
        \endcode
        \note Pay attention to the keywords that are reserved in QML or
        JavaScript context, but not reserved in *.proto context. These words
        will be silently renamed by the
        \l {The qtprotobufgen Tool}{generator plugin}.
        For example, \c id, \c property, and \c import are reserved keywords.
        They will be replaced by \c id_proto, \c property_proto,
        \c import_proto:
        \badcode
            message MessageUpperCaseReserved {
                sint32 Import = 1;
                sint32 Property = 2;
                sint32 Id = 3;
            }
        \endcode
        Generated code output:
        \code
            Q_PROPERTY(QtProtobuf::sint32 import_proto READ import_proto ...)
            Q_PROPERTY(QtProtobuf::sint32 property_proto READ property_proto ...)
            Q_PROPERTY(QtProtobuf::sint32 id_proto READ id_proto ...)
        \endcode
        Also, enum values cannot begin with a lower case letter.
        The \l {The qtprotobufgen Tool}{generator plugin} will capitalize
        the first letter in code output. See the \c *.proto example below:
        \badcode
            enum LowerCaseEnum {
                enumValue0 = 0;
                enumValue1 = 1;
                enumValue2 = 2;
            }
        \endcode
        Generated code output:
        \code
            enum LowerCaseEnum {
                EnumValue0 = 0,
                EnumValue1 = 1,
                EnumValue2 = 2,
            };
            Q_ENUM(LowerCaseEnum)
        \endcode
        Also, enum fields cannot begin with an underscore symbol.
        Such fields will be generated as is, but will be undefined in
        the QML context, unless the QML engine will allow registering
        them in the future. See the \c *.proto example below:
        \badcode
            enum UnderScoreEnum {
                _enumUnderscoreValue0 = 0;
                _EnumUnderscoreValue1 = 1;
            }
        \endcode
        Generated output:
        \code
            enum UnderScoreEnum {
                _enumUnderscoreValue0 = 0,
                _EnumUnderscoreValue1 = 1,
            };
            Q_ENUM(UnderScoreEnum)
        \endcode
        For more information about the QML properties syntax, check
        \l {Defining Property Attributes}.
        \note If the \c QML_URI is skipped, all *.proto files specified
        in the \c qt_add_protobuf command should have the same \c protobuf
        package name, since it shall be used as a default \c URI for the
        resulting QML module.
        \note You should avoid creating several QML modules with the same
        \c QML_URI or proto package name, because it leads to import error
        in QML context.

    \include qtprotogen-options.qdocinc
    \include qtprotogen-cmake-options.qdocinc
\endlist

\sa{The qtprotobufgen Tool}

\section1 Example

\include qt-add-protobuf-example.qdocinc
*/
