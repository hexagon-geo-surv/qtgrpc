// Copyright (C) 2022 The Qt Company Ltd.
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GFDL-1.3-no-invariants-only

/*!
\page qt_add_protobuf.html
\ingroup cmake-commands-qtprotobuf

\title qt_add_protobuf
\target qt6_add_protobuf
\summary {Generates Qt-based C++ source code using a protobuf schema}
\preliminarycmakecommand
\cmakecommandsince 6.5

Usually \c qtprotobufgen would be invoked through CMake using the
\c qt_add_protobuf macro.

\badcode
    qt_add_protobuf(<target>
        PROTO_FILES <file> ...
        [COPY_COMMENTS]
        [GENERATE_PACKAGE_SUBFOLDERS]
        [EXTRA_NAMESPACE <namespace>]
        [EXPORT_MACRO <infix>]
        [QML [QML_URI <uri>]]
        [PROTO_INCLUDES <path> ...]
        [OUTPUT_DIRECTORY <dir>]
        [OUTPUT_HEADERS <var>]
        [OUTPUT_TARGETS <var>]
    )
\endcode

The source files generated by \c qtprotobufgen are then added to the target.
If the target already exists, the files are \e added to the target source
list. If the target doesn't exist, it is created as a library which you must
link to.

\section1 Arguments
\list
    \include qtprotoccommon-options.qdocinc
    \li \c QML enables QProtobufMessage types in QML context by registering
        them as a QML module. For such purpose, the \l {qt_add_qml_module}
        CMake macro is called inside the \c protobuf function.
        Every QML module has to define a \c URI name. Other QML modules may
        use this name in \l{qtqml-syntax-imports.html}{import statements}
        to import the module into a user application. Use the \c QML_URI
        option to set the \c URI name. It has to be specified in dotted
        notation, e.g. \c {Qt.Protobuf.Package}.
        If \c QML_URI is omitted, then the protobuf package name will be used
        as the module \c URI.
        Pay attention, the \c protobuf function always creates a new QML
        module. It means it cannot be used to extend existing targets.
        For example, following cases are prohibited:
        \badcode
            qt_add_qml_module(targetname
                ...
            )

            qt_add_protobuf(targetname
            QML
                ...
            )
        \endcode

        \badcode
            qt_add_executable(targetname
                ...
            )

            qt_add_protobuf(targetname
            QML
                ...
            )
        \endcode
        \note If the \c QML_URI is skipped, all *.proto files specified
        in the \c qt_add_protobuf function should have the same \c protobuf
        package name, since it shall be used as a default \c URI for the
        resulting QML module.
        \note You should escape creating several QML modules with the same
        \c QML_URI or proto package name, because it leads to import error
        in QML context.

    \include qtprotogen-options.qdocinc
    \include qtprotogen-cmake-options.qdocinc
\endlist

\sa{The qtprotobufgen Tool}

\section1 Example

\include qt-add-protobuf-example.qdocinc
*/
