// Copyright (C) 2022 The Qt Company Ltd.
// Copyright (C) 2019 Alexey Edelev <semlanik@gmail.com>, Tatyana Borisova <tanusshhka@mail.ru>
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only WITH Qt-GPL-exception-1.0

#include "templates.h"
#include <unordered_map>

// Templates navigation map:
// All template functions are named as following(with some exceptions):
//     <CommonTemplateType>[TemplateSubject][Declaration|Definition]Template
//
// CommonTemplateType usually describes what template implements e.g. Constructor, Member,
// Property etc.
//
// TemplateSubject is the type that the template is applicable for. The following naming is used for
// the common types:
// ''(empty) - for integral types like int32, fixed32, bool, etc.
// Map       - any map types.
// Repeated  - any repeated types.
// Complex   - means that template is applicable for any non-trivially desctructable types, except
//             messages.
// Message   - for any general protobuf message that is represented as the pointer with lazy
//             initialization
// Enum      - any enum types.
// Optional  - any field that behaves like optional field.
//
// Map and Repeated can be combined with one of Complex, Message or Enum keywords, that indicates
// the specialization of the template.

using namespace ::QtProtobuf::generator;

const char *Templates::ProtoSuffix()
{
    return "_proto";
}

const std::vector<std::string> &Templates::ListOfQmlExceptions()
{
    static std::vector<std::string> vec{ { "id", "property", "import" } };
    return vec;
}

const char *Templates::DefaultProtobufIncludesTemplate()
{
    return "#include <QtCore/QMetaType>\n"
           "#include <QtCore/QList>\n"
           "\n"
           "#include <QtProtobuf/qprotobufobject.h>\n"
           "#include <QtProtobuf/qprotobuflazymessagepointer.h>\n"
           "\n"
           "#include <memory>\n"
           "\n";
}

const char *Templates::QmlProtobufIncludesTemplate()
{
    return "#include <QtQml/QQmlListProperty>\n"
           "#include <QtProtobufQuick/qtprotobufqmllistpropertyconstructor.h>\n\n";
}

const char *Templates::DisclaimerTemplate()
{
    return "/* This file is autogenerated. DO NOT CHANGE. All changes will be lost */\n\n";
}

const char *Templates::PreambleTemplate()
{
    return "#ifndef Q_PROTOBUF_$filename$_H\n"
           "#define Q_PROTOBUF_$filename$_H\n\n"
           "#include <QtProtobuf/QProtobufMessage>\n";
}

const char *Templates::FooterTemplate()
{
    return "#endif // Q_PROTOBUF_$filename$_H\n";
}

const char *Templates::InternalIncludeTemplate()
{
    return "#include \"$include$.h\"\n";
}
const char *Templates::ExternalIncludeTemplate()
{
    return "#include <$include$>\n";
}
const char *Templates::GlobalEnumIncludeTemplate()
{
    return "#include <globalenums.h>\n";
}

const char *Templates::EnumRegistrationDeclaration()
{
    return "$export_macro$ void registerTypes();\n";
}

const char *Templates::MetaTypeRegistrationDeclaration()
{
    return "static void registerTypes();\n";
}
const char *Templates::MetaTypeRegistrationMessageDefinition()
{
    return "void $type$::registerTypes()\n{\n"
           "    qRegisterMetaType<$type$>();\n"
           "    qRegisterMetaType<$list_type$>();\n";
}
const char *Templates::MetaTypeRegistrationGlobalEnumDefinition()
{
    return "void $enum_gadget$::registerTypes()\n{\n";
}
const char *Templates::MetaTypeRegistrationGlobalEnumTemplate()
{
    return "qRegisterMetaType<$type$>();\n"
           "qRegisterMetaType<$full_type$>();\n";
}
const char *Templates::UsingMessageTemplate()
{
    return "using $classname$Repeated = QList<std::shared_ptr<$classname$>>;\n";
}
const char *Templates::UsingMapTemplate()
{
    return "using $type$ = QHash<$key_type$, $value_type$>;\n";
}
const char *Templates::UsingMapMessageTemplate()
{
    return "using $type$ = QHash<$key_type$, std::shared_ptr<$value_type$>>;\n";
}
const char *Templates::UsingNestedMessageTemplate()
{
    return "using $type$ = $scope_namespaces$::$type$;\n"
           "using $list_type$ = $scope_namespaces$::$list_type$;\n";
}

const char *Templates::UsingRepeatedEnumTemplate()
{
    return "using $list_type$ = QList<$type$>;\n";
}

const char *Templates::NamespaceTemplate()
{
    return "namespace $scope_namespaces$ {\n";
}
const char *Templates::NamespaceClosingTemplate()
{
    return "} // namespace $scope_namespaces$\n";
}
const char *Templates::EnumDeclarationTemplate()
{
    return "\nnamespace $classname$ {\n"
           "Q_NAMESPACE_EXPORT($export_macro$)\n";
}
const char *Templates::ClassMessageForwardDeclarationTemplate()
{
    return "class $classname$;\n";
}
const char *Templates::ClassMessageBeginDeclarationTemplate()
{
    return "\nclass $export_macro$ $classname$ : public QProtobufMessage\n"
           "{\n"
           "    Q_GADGET\n"
           "    Q_PROTOBUF_OBJECT\n"
           "    Q_DECLARE_PROTOBUF_SERIALIZERS($classname$)\n";
}

const char *Templates::PropertyTemplate()
{
    return "Q_PROPERTY($property_type$ $property_name$ READ $property_name$ WRITE "
           "set$property_name_cap$ SCRIPTABLE $scriptable$)\n";
}
const char *Templates::PropertyRepeatedTemplate()
{
    return "Q_PROPERTY($property_list_type$ $property_name$ READ $property_name$ WRITE "
           "set$property_name_cap$ SCRIPTABLE $scriptable$)\n";
}
const char *Templates::PropertyRepeatedMessageTemplate()
{
    return "Q_PROPERTY($property_list_type$ $property_name$Data READ $property_name$ WRITE "
           "set$property_name_cap$ SCRIPTABLE $scriptable$)\n";
}
const char *Templates::PropertyNonScriptableTemplate()
{
    return "Q_PROPERTY($property_type$ $property_name$_p READ $property_name$ WRITE "
           "set$property_name_cap$ SCRIPTABLE false)\n";
}
const char *Templates::PropertyNonScriptableAliasTemplate()
{
    return "Q_PROPERTY($qml_alias_type$ $property_name$ READ $property_name$_p WRITE "
           "set$property_name_cap$_p SCRIPTABLE true)\n";
}
const char *Templates::PropertyMessageTemplate()
{
    return "Q_PROPERTY($property_type$ *$property_name$ READ $property_name$_p WRITE "
           "set$property_name_cap$_p)\n";
}
const char *Templates::PropertyQmlListTemplate()
{
    return "Q_PROPERTY(QQmlListProperty<$property_type$> $property_name$ READ $property_name$_l)\n";
}

const char *Templates::ConstructorMessageDeclarationTemplate()
{
    return "$classname$();\n";
}

const char *Templates::DestructorMessageDeclarationTemplate()
{
    return "~$classname$() override;\n";
}

const char *Templates::MemberTemplate()
{
    return "$scope_type$ m_$property_name$;\n";
}
const char *Templates::MemberRepeatedTemplate()
{
    return "$scope_list_type$ m_$property_name$;\n";
}
const char *Templates::MemberMessageTemplate()
{
    return "QtProtobufPrivate::QProtobufLazyMessagePointer<$scope_type$> m_$property_name$;\n";
}
const char *Templates::PublicBlockTemplate()
{
    return "\npublic:\n";
}
const char *Templates::PrivateBlockTemplate()
{
    return "\nprivate:\n";
}
const char *Templates::EnumDefinitionTemplate()
{
    return "enum $type$ {\n";
}
const char *Templates::EnumFieldTemplate()
{
    return "$enumvalue$ = $value$,\n";
}

const char *Templates::ConstructorMessageDefinitionTemplate()
{
    return "$type$::$type$() : QProtobufMessage(&$type$::staticMetaObject)";
}

const char *Templates::EmptyConstructorTemplate()
{
    return "$classname$() {}\n";
}

const char *Templates::QObjectConstructorMessageDeclarationTemplate()
{
    return "explicit $classname$(QObject *parent = nullptr);\n";
}

const char *Templates::CopyConstructorDeclarationTemplate()
{
    return "$classname$(const $classname$ &other);\n";
}
const char *Templates::MoveConstructorDeclarationTemplate()
{
    return "$classname$($classname$ &&other) noexcept;\n";
}
const char *Templates::CopyConstructorDefinitionTemplate()
{
    return "$classname$::$classname$(const $classname$ &other) : "
           "QProtobufMessage(other)";
}
const char *Templates::MoveConstructorDefinitionTemplate()
{
    return "$classname$::$classname$($classname$ &&other) noexcept : "
           "QProtobufMessage(std::move(other))";
}
const char *Templates::DeletedCopyConstructorTemplate()
{
    return "$classname$(const $classname$ &) = delete;\n";
}
const char *Templates::DeletedMoveConstructorTemplate()
{
    return "$classname$($classname$ &&) = delete;\n";
}
const char *Templates::CopyMemberTemplate()
{
    return "set$property_name_cap$(other.m_$property_name$);\n";
}
const char *Templates::CopyMemberMessageTemplate()
{
    return "if (m_$property_name$ != other.m_$property_name$) {\n"
           "    *m_$property_name$ = *other.m_$property_name$;\n"
           "}\n";
}
const char *Templates::AssignMemberMessageTemplate()
{
    return "if (m_$property_name$ != other.m_$property_name$)\n"
           "    *m_$property_name$ = *other.m_$property_name$;\n";
}
const char *Templates::MoveMemberMessageTemplate()
{
    return "if (m_$property_name$ != other.m_$property_name$) {\n"
           "    *m_$property_name$ = std::move(*other.m_$property_name$);\n"
           "}\n";
}
const char *Templates::MoveAssignMemberMessageTemplate()
{
    return "if (m_$property_name$ != other.m_$property_name$)\n"
           "    *m_$property_name$ = std::move(*other.m_$property_name$);\n";
}
const char *Templates::MoveAssignMemberComplexTemplate()
{
    return "if (m_$property_name$ != other.m_$property_name$)\n"
           "    m_$property_name$ = std::move(other.m_$property_name$);\n";
}

const char *Templates::MoveConstructorMemberComplexTemplate()
{
    return "m_$property_name$ = std::move(other.m_$property_name$);\n";
}

const char *Templates::MoveMemberTemplate()
{
    return "set$property_name_cap$(std::exchange(other.m_$property_name$, 0));\n";
}
const char *Templates::MoveMemberEnumTemplate()
{
    return "m_$property_name$ = other.m_$property_name$;\n";
}

const char *Templates::AssignmentOperatorDeclarationTemplate()
{
    return "$classname$ &operator =(const $classname$ &other);\n";
}
const char *Templates::AssignmentOperatorDefinitionTemplate()
{
    return "$classname$ &$classname$::operator =(const $classname$ &other)\n"
           "{\n"
           "    QProtobufMessage::operator=(other);\n";
}
const char *Templates::AssignmentOperatorReturnTemplate()
{
    return "return *this;\n";
}

const char *Templates::MoveAssignmentOperatorDeclarationTemplate()
{
    return "$classname$ &operator =($classname$ &&other) noexcept;\n";
}
const char *Templates::MoveAssignmentOperatorDefinitionTemplate()
{
    return "$classname$ &$classname$::operator =($classname$ &&other) noexcept\n"
           "{\n"
           "    QProtobufMessage::operator=(std::move(other));\n";
}

const char *Templates::EqualOperatorDeclarationTemplate()
{
    return "bool operator ==(const $classname$ &other) const;\n";
}
const char *Templates::EqualOperatorDefinitionTemplate()
{
    return "bool $classname$::operator ==(const $classname$ &other) const\n{\n"
           "    return QProtobufMessage::isEqual(*this, other)";
}
const char *Templates::EqualOperatorMemberTemplate()
{
    return "m_$property_name$ == other.m_$property_name$";
}
const char *Templates::EqualOperatorMemberMessageTemplate()
{
    return "(m_$property_name$ == other.m_$property_name$\n"
           "    || *m_$property_name$ == *other.m_$property_name$)\n";
}
const char *Templates::EqualOperatorMemberRepeatedTemplate()
{
    return "QtProtobuf::repeatedValueCompare(m_$property_name$, other.m_$property_name$)";
}

const char *Templates::NotEqualOperatorDeclarationTemplate()
{
    return "bool operator !=(const $classname$ &other) const;\n";
}
const char *Templates::NotEqualOperatorDefinitionTemplate()
{
    return "bool $classname$::operator !=(const $classname$ &other) const\n{\n"
           "    return !this->operator ==(other);\n"
           "}\n\n";
}

const char *Templates::PrivateGetterMessageDeclarationTemplate()
{
    return "$getter_type$ *$property_name$_p() const;\n";
}
const char *Templates::PrivateGetterMessageDefinitionTemplate()
{
    return "$getter_type$ *$classname$::$property_name$_p() const\n{\n"
           "    return m_$property_name$.get();\n"
           "}\n\n";
}

const char *Templates::GetterMessageDeclarationTemplate()
{
    return "$getter_type$ &$property_name$() const;\n";
}
const char *Templates::GetterMessageDefinitionTemplate()
{
    return "$getter_type$ &$classname$::$property_name$() const\n{\n"
           "    return *m_$property_name$;\n"
           "}\n\n";
}

const char *Templates::GetterTemplate()
{
    return "$getter_type$ $property_name$() const {\n"
           "    return m_$property_name$;\n"
           "}\n\n";
}

const char *Templates::GetterNonScriptableTemplate()
{
    return "$qml_alias_type$ $property_name$_p() const {\n"
           "    return m_$property_name$;\n"
           "}\n\n";
}

const char *Templates::GetterComplexTemplate()
{
    return "$getter_type$ &$property_name$() {\n"
           "    return m_$property_name$;\n"
           "}\n\n";
}

const char *Templates::GetterQmlListDeclarationTemplate()
{
    return "QQmlListProperty<$scope_type$> $property_name$_l();\n";
}
const char *Templates::GetterQmlListDefinitionTemplate()
{
    return "QQmlListProperty<$full_type$> $classname$::$property_name$_l()\n{\n"
           "    return qProtobufConstructQmlListProperty<$scope_type$>(this, &m_$property_name$);\n"
           "}\n\n";
}

const char *Templates::PrivateSetterMessageDeclarationTemplate()
{
    return "void set$property_name_cap$_p($setter_type$ *$property_name$);\n";
}
const char *Templates::PrivateSetterMessageDefinitionTemplate()
{
    return "void $classname$::set$property_name_cap$_p($setter_type$ *$property_name$)\n{\n"
           "    if (m_$property_name$.get() != $property_name$)\n"
           "        m_$property_name$.reset($property_name$);\n"
           "}\n\n";
}

const char *Templates::SetterMessageDeclarationTemplate()
{
    return "void set$property_name_cap$(const $setter_type$ &$property_name$);\n";
}
const char *Templates::SetterMessageDefinitionTemplate()
{
    return "void $classname$::set$property_name_cap$(const $setter_type$ &$property_name$)\n{\n"
           "    if (*m_$property_name$ != $property_name$)\n"
           "        *m_$property_name$ = $property_name$;\n"
           "}\n\n";
}

const char *Templates::SetterComplexDeclarationTemplate()
{
    return "void set$property_name_cap$(const $setter_type$ &$property_name$);\n";
}
const char *Templates::SetterComplexDefinitionTemplate()
{
    return "void $classname$::set$property_name_cap$(const $setter_type$ &$property_name$)\n{\n"
           "    if (m_$property_name$ != $property_name$)\n"
           "        m_$property_name$ = $property_name$;\n"
           "}\n\n";
}

const char *Templates::SetterTemplate()
{
    return "void set$property_name_cap$(const $setter_type$ &$property_name$) {\n"
           "    if (m_$property_name$ != $property_name$)\n"
           "        m_$property_name$ = $property_name$;\n"
           "}\n\n";
}
const char *Templates::SetterNonScriptableTemplate()
{
    return "void set$property_name_cap$_p(const $qml_alias_type$ &$property_name$) {\n"
           "    if (m_$property_name$ != $property_name$)\n"
           "        m_$property_name$ = $property_name$;\n"
           "}\n\n";
}

const char *Templates::SignalsBlockTemplate()
{
    return "\nQ_SIGNALS:\n";
}
const char *Templates::SignalTemplate()
{
    return "void $property_name$Changed();\n";
}

const char *Templates::MetaDataUintDataEntryTemplate()
{
    return "const std::array<uint, $size$> qt_protobuf_$classname$_uint_data =";
}

const char *Templates::MetaDataCharDataEntryTemplate()
{
    return "const char qt_protobuf_$classname$_char_data[$size$] =";
}

const char *Templates::JsonNameOffsetsUintDataTemplate()
{
    return "$json_name_offset$, /* = $json_name$ */\n";
}

const char *Templates::FieldNumbersUintDataTemplate()
{
    return "$field_number$, /* = $json_name$ */\n";
}

const char *Templates::QtPropertyIndicesUintDataTemplate()
{
    return "$property_index$, /* = $json_name$ */\n";
}

const char *Templates::FieldFlagsUintDataTemplate()
{
    return "$field_flags$, /* = $json_name$ */\n";
}

const char *Templates::PropertyOrderingDataOpeningTemplate()
{
    return "static constexpr struct {\n"
           "    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;\n"
           "    const std::array<uint, $uint_size$> qt_protobuf_$classname$_uint_data;\n"
           "    const char qt_protobuf_$classname$_char_data[$char_size$];\n"
           "} qt_protobuf_$classname$_metadata {\n"
           "    // data\n"
           "    {\n"
           "        $version_number$, /* = version */\n"
           "        $num_fields$, /* = num fields */\n"
           "        $field_number_offset$, /* = field number offset */\n"
           "        $property_index_offset$, /* = property index offset */\n"
           "        $field_flags_offset$, /* = field flags offset */\n"
           "        $message_full_name_size$, /* = message full name length */\n"
           "    },\n";
}

const char *Templates::PropertyOrderingDataClosingTemplate()
{
    return "};\n\n";
}
const char *Templates::PropertyOrderingDefinitionTemplate()
{
    return "const QtProtobufPrivate::QProtobufPropertyOrdering $type$::propertyOrdering = {\n"
           "    &qt_protobuf_$classname$_metadata.data\n"
           "};\n\n";
}

const char *Templates::SimpleBlockEnclosureTemplate()
{
    return "}\n";
}
const char *Templates::SemicolonBlockEnclosureTemplate()
{
    return "};\n";
}
const char *Templates::InitializerMemberTemplate()
{
    return "m_$property_name$($initializer$)";
}
const char *Templates::InitializerMemberMessageTemplate()
{
    return "m_$property_name$(nullptr)";
}
const char *Templates::EmptyBracesTemplate()
{
    return "\n{\n}\n";
}

const char *Templates::DeclareMetaTypeTemplate()
{
    return "Q_DECLARE_METATYPE($full_type$)\n";
}

const char *Templates::DeclareMetaTypeQmlListTemplate()
{
    return "Q_DECLARE_METATYPE(QQmlListProperty<$full_type$>)\n";
}

const char *Templates::MetaTypeRegistrationLocalEnumTemplate()
{
    return "qRegisterProtobufEnumType<$scope_type$>();\n"
           "qRegisterMetaType<$scope_type$>();\n"
           "qRegisterMetaType<$scope_type$>();\n"
           "qRegisterMetaType<$scope_list_type$>();\n";
}
const char *Templates::MetaTypeRegistrationMapTemplate()
{
    return "qRegisterMetaType<$scope_type$>();\n"
           "qRegisterProtobufMapType<$key_type$, $value_type$>();\n";
}

const char *Templates::MetaTypeRegistrationQmlListTemplate()
{
    return "qRegisterMetaType<QQmlListProperty<$full_type$>>();\n";
}

const char *Templates::QEnumTemplate()
{
    return "Q_ENUM($type$)\n";
}

const char *Templates::QEnumNSTemplate()
{
    return "Q_ENUM_NS($type$)\n";
}

const char *Templates::RegisterEnumSerializersTemplate()
{
    return "qRegisterProtobufEnumType<$full_type$>();\n";
}
const char *Templates::RegistrarTemplate()
{
    return "static QtProtobuf::ProtoTypeRegistrar "
           "ProtoTypeRegistrar$classname$(qRegisterProtobufType<$classname$>);\n";
}
const char *Templates::RegistrarEnumTemplate()
{
    return "static QtProtobuf::ProtoTypeRegistrar "
           "ProtoTypeRegistrar$enum_gadget$($enum_gadget$::registerTypes);\n";
}
const char *Templates::QmlRegisterTypeTemplate()
{
    return "qmlRegisterType<$scope_type$>(\"$qml_package$\", 1, 0, \"$type$\");\n";
}
const char *Templates::QmlRegisterTypeEnumTemplate()
{
    return "qmlRegisterUncreatableType<$enum_gadget$>(\"$qml_package$\", 1, 0, \"$type$\", "
           "QStringLiteral(\"$full_type$ Could not be created from qml context\"));\n";
}

const char *Templates::RepeatedSuffix()
{
    return "Repeated";
}

// Those marked "Limited" have limited usage in QML, since QML only supports signed integers.
// See https://doc.qt.io/qt-6/qtqml-typesystem-valuetypes.html for types that are supported by the
// QML JS engine.
const std::unordered_map<::google::protobuf::FieldDescriptor::Type, std::string>
        &Templates::TypeReflection()
{
    static std::unordered_map<::google::protobuf::FieldDescriptor::Type, std::string> map{
        { ::google::protobuf::FieldDescriptor::TYPE_DOUBLE, "double" },
        { ::google::protobuf::FieldDescriptor::TYPE_FLOAT, "float" },
        { ::google::protobuf::FieldDescriptor::TYPE_INT64, "int64" }, // Limited
        { ::google::protobuf::FieldDescriptor::TYPE_UINT64, "uint64" }, // Limited
        { ::google::protobuf::FieldDescriptor::TYPE_INT32, "int32" },
        { ::google::protobuf::FieldDescriptor::TYPE_FIXED64, "fixed64" }, // Limited
        { ::google::protobuf::FieldDescriptor::TYPE_FIXED32, "fixed32" },
        { ::google::protobuf::FieldDescriptor::TYPE_BOOL, "bool" },
        { ::google::protobuf::FieldDescriptor::TYPE_STRING, "QString" },
        { ::google::protobuf::FieldDescriptor::TYPE_BYTES, "QByteArray" },
        { ::google::protobuf::FieldDescriptor::TYPE_UINT32, "uint32" }, // Limited
        { ::google::protobuf::FieldDescriptor::TYPE_SFIXED32, "sfixed32" },
        { ::google::protobuf::FieldDescriptor::TYPE_SFIXED64, "sfixed64" }, // Limited
        { ::google::protobuf::FieldDescriptor::TYPE_SINT32, "sint32" },
        { ::google::protobuf::FieldDescriptor::TYPE_SINT64, "sint64" } // Limited
    };
    return map;
}

const char *Templates::ProtoFileSuffix()
{
    return ".qpb";
}

const char *Templates::GrpcClientFileSuffix()
{
    return "_client.grpc";
}

const char *Templates::GrpcServiceFileSuffix()
{
    return "_service.grpc";
}

const char *Templates::EnumClassSuffix()
{
    return "Gadget";
}

const char *Templates::QtProtobufNamespace()
{
    return "QtProtobuf";
}
const char *Templates::QtProtobufNestedNamespace()
{
    return "_QtProtobufNested";
}

const char *Templates::QtProtobufFieldEnum()
{
    return "QtProtobufFieldEnum";
}
const char *Templates::FieldEnumTemplate()
{
    return "enum QtProtobufFieldEnum {\n";
}
const char *Templates::FieldNumberTemplate()
{
    return "$property_name_cap$ProtoFieldNumber = $number$,\n";
}

const char *Templates::ExportMacroTemplate()
{
    return "#if defined(QT_SHARED) || !defined(QT_STATIC)\n"
           "#  if defined(QT_BUILD_$export_macro$_LIB)\n"
           "#    define QPB_$export_macro$_EXPORT Q_DECL_EXPORT\n"
           "#  else\n"
           "#    define QPB_$export_macro$_EXPORT Q_DECL_IMPORT\n"
           "#  endif\n"
           "#else\n"
           "#  define QPB_$export_macro$_EXPORT\n"
           "#endif\n";
}

const char *Templates::ChildClassDeclarationTemplate()
{
    return "\nclass $export_macro$ $classname$ : public $parent_class$\n"
           "{\n"
           "    Q_OBJECT\n";
}

const char *Templates::ClientMethodDeclarationSyncTemplate()
{
    return "QGrpcStatus $method_name$(const $param_type$ &$param_name$, "
           "$return_type$ *$return_name$);\n";
}

const char *Templates::ClientMethodDeclarationAsyncTemplate()
{
    return "std::shared_ptr<QGrpcCallReply> $method_name$(const $param_type$ &$param_name$);\n";
}

const char *Templates::ClientMethodDeclarationAsync2Template()
{
    return "Q_INVOKABLE void $method_name$(const $param_type$ &$param_name$, const QObject "
           "*context, "
           "const std::function<void(std::shared_ptr<QGrpcCallReply>)> &callback);\n";
}

const char *Templates::ClientMethodDeclarationQmlTemplate()
{
    return "Q_INVOKABLE void $method_name$($param_type$ *$param_name$, const QJSValue &callback, "
           "const QJSValue &errorCallback);\n";
}

const char *Templates::ClientMethodDeclarationQml2Template()
{
    return "Q_INVOKABLE void $method_name$($param_type$ *$param_name$, $return_type$ "
           "*$return_name$, const QJSValue &errorCallback);\n";
}

const char *Templates::ServerMethodDeclarationTemplate()
{
    return "Q_INVOKABLE virtual $return_type$ $method_name$(const $param_type$ &$param_name$) = "
           "0;\n";
}

const char *Templates::ClientConstructorDefinitionTemplate()
{
    return "\n$classname$::$classname$(QObject *parent) : $parent_class$(\"$service_name$\", "
           "parent)\n"
           "{\n"
           "}\n";
}

const char *Templates::ClientMethodDefinitionSyncTemplate()
{
    return "\nQGrpcStatus $classname$::$method_name$(const $param_type$ &$param_name$, "
           "$return_type$ *$return_name$)\n"
           "{\n"
           "    return call<$param_type$>(\"$method_name$\", $param_name$, $return_name$);\n"
           "}\n";
}

const char *Templates::ClientMethodDefinitionAsyncTemplate()
{
    return "\nstd::shared_ptr<QGrpcCallReply> $classname$::$method_name$(const $param_type$ "
           "&$param_name$)\n"
           "{\n"
           "    return call<$param_type$>(\"$method_name$\", $param_name$);\n"
           "}\n";
}

const char *Templates::ClientMethodDefinitionAsync2Template()
{
    return "\nvoid $classname$::$method_name$(const $param_type$ &$param_name$, const QObject "
           "*context, const std::function<void(std::shared_ptr<QGrpcCallReply>)> &callback)\n"
           "{\n"
           "    std::shared_ptr<QGrpcCallReply> reply = call<$param_type$>(\"$method_name$\", "
           "$param_name$);\n"
           "    QObject::connect(reply.get(), &QGrpcCallReply::finished, context, [reply, "
           "callback]() "
           "{\n"
           "        callback(reply);\n"
           "    });\n"
           "}\n";
}

const char *Templates::ClientMethodDefinitionQmlTemplate()
{
    return "\nvoid $classname$::$method_name$($param_type$ *$param_name$, const QJSValue "
           "&callback, "
           "const QJSValue &errorCallback)\n"
           "{\n"
           "    if (!callback.isCallable()) {\n"
           "        qWarning() << \"Unable to call $classname$::$method_name$, callback is not "
           "callable\";\n"
           "        return;\n"
           "    }\n\n"
           "    if (arg == nullptr) {\n"
           "        qWarning() << \"Invalid argument provided for method "
           "$classname$::$method_name$, "
           "argument of type '$param_type$ *' expected\";\n"
           "        return;\n"
           "    }\n\n"
           "    QJSEngine *jsEngine = qjsEngine(this);\n"
           "    if (jsEngine == nullptr) {\n"
           "        qWarning() << \"Unable to call $classname$::$method_name$, it's only callable "
           "from JS engine context\";\n"
           "        return;\n"
           "    }\n\n"
           "    std::shared_ptr<QGrpcCallReply> reply = call<$param_type$>(\"$method_name$\", "
           "*$param_name$);\n"
           "    reply->subscribe(jsEngine, [this, reply, callback, jsEngine]() {\n"
           "        auto result = new $return_type$(reply->read<$return_type$>());\n"
           "        qmlEngine(this)->setObjectOwnership(result, QQmlEngine::JavaScriptOwnership);\n"
           "        QJSValue(callback).call(QJSValueList{jsEngine->toScriptValue(result)});\n"
           "    }, [errorCallback, jsEngine](const QGrpcStatus &status) {\n"
           "        QJSValue(errorCallback).call(QJSValueList{jsEngine->toScriptValue(status)});\n"
           "    });\n"
           "}\n";
}

const char *Templates::ClientMethodDefinitionQml2Template()
{
    return "\nvoid $classname$::$method_name$($param_type$ *$param_name$, $return_type$ "
           "*$return_name$, const QJSValue &errorCallback)\n"
           "{\n"
           "    if ($return_name$ == nullptr) {\n"
           "        qWarning() << \"Invalid argument provided for method "
           "$classname$::$method_name$, "
           "argument of type '$return_type$ *' expected\";\n"
           "        return;\n"
           "    }\n\n"
           "    QWeakPointer<$return_type$> safeReturn($return_name$);\n\n"
           "    if ($param_name$ == nullptr) {\n"
           "        qWarning() << \"Invalid argument provided for method "
           "$classname$::$method_name$, "
           "argument of type '$param_type$ *' expected\";\n"
           "        return;\n"
           "    }\n\n"
           "    QJSEngine *jsEngine = qjsEngine(this);\n"
           "    if (jsEngine == nullptr) {\n"
           "        qWarning() << \"Unable to call $classname$::$method_name$, it's only callable "
           "from JS engine context\";\n"
           "        return;\n"
           "    }\n\n"
           "    std::shared_ptr<QGrpcCallReply> reply = call<$param_type$>(\"$method_name$\", "
           "*$param_name$);\n"
           "    reply->subscribe(jsEngine, [this, reply, jsEngine, safeReturn]() {\n"
           "        if (safeReturn.isNull()) {\n"
           "            qWarning() << \"Return value is destroyed. Ignore call result\";\n"
           "            return;\n"
           "        }\n"
           "        *safeReturn = $return_type$(reply->read<$return_type$>());\n"
           "    }, [errorCallback, jsEngine](const QGrpcStatus &status) {\n"
           "        QJSValue(errorCallback).call(QJSValueList{jsEngine->toScriptValue(status)});\n"
           "    });\n"
           "}\n";
}

const char *Templates::ClientMethodServerStreamDeclarationTemplate()
{
    return "std::shared_ptr<QGrpcStream> stream$method_name_upper$(const $param_type$ "
           "&$param_name$);\n";
}

const char *Templates::ClientMethodServerStream2DeclarationTemplate()
{
    return "std::shared_ptr<QGrpcStream> stream$method_name_upper$(const $param_type$ "
           "&$param_name$, const "
           "QWeakPointer<$return_type$> &$return_name$);\n";
}

const char *Templates::ClientMethodServerStreamQmlDeclarationTemplate()
{
    return "Q_INVOKABLE std::shared_ptr<QGrpcStream> qmlStream$method_name_upper$_p($param_type$ "
           "*$param_name$, "
           "$return_type$ *$return_name$);\n";
}

const char *Templates::ClientMethodServerStreamDefinitionTemplate()
{
    return "std::shared_ptr<QGrpcStream> $classname$::stream$method_name_upper$(const $param_type$ "
           "&$param_name$)\n"
           "{\n"
           "    return stream<$param_type$>(\"$method_name$\", $param_name$);\n"
           "}\n";
}

const char *Templates::ClientMethodServerStream2DefinitionTemplate()
{
    return "std::shared_ptr<QGrpcStream> $classname$::stream$method_name_upper$(const $param_type$ "
           "&$param_name$, const QWeakPointer<$return_type$> &$return_name$)\n"
           "{\n"
           "    return stream<$param_type$>(\"$method_name$\", $param_name$, $return_name$);\n"
           "}\n";
}

const char *Templates::ClientMethodServerStreamQmlDefinitionTemplate()
{
    return "std::shared_ptr<QGrpcStream> $classname$::qmlStream$method_name_upper$_p($param_type$ "
           "*$param_name$, "
           "$return_type$ *$return_name$)\n"
           "{\n"
           "    return stream<$param_type$>(\"$method_name$\", *$param_name$, "
           "QWeakPointer<$return_type$>($return_name$));\n"
           "}\n";
}
